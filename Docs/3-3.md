# 3.3 常量和变量

## 3.3.1 常量
常量使用关键字 const 定义，用于存储不会改变的数据。

存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

常量的定义格式：
```go
const identifier [type] = value
```
例如：

```go
// 显示定义
const Pi float = 3.14159
// 隐式定义
const Pi = 3.14159
```
在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。
- 显式类型定义： const b string = "abc"
- 隐式类型定义： const b = "abc"

一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。
```go
var n int
f(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int
```

常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。
- 正确的做法：`const c1 = 2/3`
- 错误的做法：`const c2 = getNumber() // 引发构建错误: getNumber() used as value`
因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。

当常量为数字类型时，是没有大小和符号的，并且可以使用任何精度而不会溢出，如果定义一个很长的数字常量，可以使用反斜杠`\`作为多行的连接符使用。

如果把一个常量赋值给精度过小的数字变量是，可能会因为无法正确表达常量所代表的数值而导致溢出，编译期间就会引发报错，另外，常量也允许并行赋值的形式。例如：
```go
const beef, two, c = "eat", 2, "veg"
const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6
const (
	Monday, Tuesday, Wednesday = 1, 2, 3
	Thursday, Friday, Saturday = 4, 5, 6
)
```

常量也可以作为枚举：
```go
const (
	Unknown = 0
	Female = 1
	Male = 2
)
```
现在，数字 0、1 和 2 分别代表未知性别、女性和男性。这些枚举值可以用于测试某个变量或常量的实际值，比如使用 switch/case 结构。



## 3.3.2 变量
### var声明语法
声明变量的一般形式是使用 var 关键字：`var identifier type`。

Go和其他语言声明变量不同的是，它声明变量是把类型放在声明的变量名称后面，可以避免类似C语言中含糊不清的声明形式，例如：`int* a, b;`。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。

而Go则可以很轻松的降这两个变量都声明为指针类型：
```go
var a, b *int
```
这样写也可以使代码从左到右阅读更为友好，更容易理解。
示例：
```go
var a int
var b bool
var str string
```
也可以写成这种形式：
```go
var (
	a int
	b bool
	str string
)
```
这种因式分解关键字的写法一般用于声明全局变量。当变量声明类型没有赋值时，系统会自动赋予该类型的零值：`int` 为 `0`，`float32(64)` 为 `0.0`，`bool` 为 `false`，`string` 为空字符串，指针为 `nil`。记住，所有的内存在 Go 中都是经过初始化的。
变量的命名规则详见：《3.2.7 Go 命名规范》和《3.2.1 包的概念、导入和可见性》中的可见性规则

一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。在 后面章节，我们将会学习到像 if 和 for 这些控制结构，而在这些结构中声明的变量的作用域只在相应的代码块内。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。

尽管变量的标识符必须是唯一的，但是在某个代码块的内存代码中使用和外部相同变量名的变量，此时外部的同名变量将会暂时隐藏（当内部代码执行结束后，内部同名变量会被释放，则外部同名变量恢复使用），代码内部的任务操作都只会影响内部代码块的局部变量。

除了上面声明变量的类型使用默认值外，也可以使用以下方法进行声明变量并赋值：
```go
a = 15
b = false

// 格式 var identifier [type] = value
var a int = 15
var i = 5
var b bool = false
var str string = "Go says hello to the world!"

// 不指定类型由Go自主推断，这个是在编译时进行推断过程
var a = 15
var b = false
var str = "Go says hello to the world!"
var (
	a = 15
	b = false
	str = "Go says hello to the world!"
	numShips = 50
	city string
)
//不过自动推断类型并不是任何时候都适用的，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型，例如：
var n int64 = 2
```

变量的类型也可以在运行是实现自动推断，例如：
```go
var (
	HOME = os.Getenv("HOME")
	USER = os.Getenv("USER")
	GOROOT = os.Getenv("GOROOT")
)
```

同一类型的多个变量可以声明在同一行，如：
```go
var a, b, c int
```
多变量可以在同一行进行赋值，如：
```go
a, b, c = 5, 7, "abc"
```
右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 "abc"。

这被称为 并行 或 同时 赋值。

如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a。

空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。

### 简短声明语法
var变量声明一般用于声明包级别的全局变量，当你在函数体内声明局部变量是，应使用简短声明语法`:=` ，例如：
```go
a := 1
```
使用简短声明语法的时候要注意，如果在同一个代码块里面已经有相同名称的变量已经声明过了，就不能在使用简短声明语法进行变量声明，例如：`a := 20` 就是不被允许的，编译器会提示错误 `no new variables on left side of :=`，但是 `a = 20` 是可以的，因为这是给相同的变量赋予一个新的值。

简短声明语法也是支持同一行进行赋值，例如：
```go
a, b, c := 5, 7, "abc"
```

不管是使用var声明还是简短声明语法，都要注意局部声明的变量必须被使用，否则会引发` declared and not used`错误。但是全局变量是允许声明但不使用。


### 值类型和引用类型
**1. 值的类型**

除了像 int、float、bool 和 string 这些基本类型都属于值类型外，数组和结构这些复合类型也是值类型.

当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝

**2. 引用类型**

当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝

你可以通过 &i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。

内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。这个内存地址被称之为**指针**，指针保存的是内存地址，直接打印是打印内存地址，如果要打印指针的值，可以使用`*r`方式打印。

当使用`r2 = r1`这种赋值的时候，只是把r1的值拷贝一份到r2的内存上，修改r1的值不会影响到r2。

如果使用的是`r3 := &r1`指针方式传递值的时候，r1修改数据，也会导致r2的数据发生改变。可以运行以下用例测试下：
```go
package main

import "fmt"

func main() {
	fmt.Println("Hello World!")
	var r1 int = 1
	var r2 int
	var r3 *int
	r2 = r1
	r3 = &r1
	fmt.Printf("%d %d %x \n", r1, r2, *r3)

	// fmt.Printf("%d %d \n", r1, r2)
	r1 = 3
	fmt.Printf("%d %d %d \n", r1, r2, *r3)
}

```


# 链接
* [目录](./directory.md)
* 上一页 [3.1 Go 的文件名、关键字和标识符](3-1.md)
* 下一页 [3.3 常量和变量](3-3.md)