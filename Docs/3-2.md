# 3.2 Go 程序的基本结构和要素

以简单的hello_world.go为例
```go
package main

import "fmt"

func main() {
	fmt.Println("hello, world")
}
```
## 3.2.1 包的概念、导入和可见性
包是结构化代码的一种方式，一个程序可以有很多个包构成，我们可以从自身或者其他包里面导入内容。每个Go文件都属于且仅属于一个包，一个包可以有多个`.go`文件，每个Go文件必须在源文件的非注释第一行指明该源文件属于哪个包，类似`package main`，`package main`表示一个可独立运行的程序，每个Go程序都必须要有一个包名为`main`的入口。其实包的概念和其他程序语言的类库或命名空间概念相似，如果了解其他程序语言的话，理解起来就比较方便。

一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。

### 标准库
Go程序在安装好后，会自带一些可以直接使用的包，即标准库，在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。

Go的标准库中包含了大量的包，(如：`fmt`和`os`等)，我们也可以自己创建自定义包，创建自定义包后可以参考（ [2.4](2-4.md) ）章节编译安装到环境中。

接下来说下程序的构建顺序，包和包内的文件必须以正确的顺序进行编译，包的依赖关系决定了其编译构建顺序。通常情况下，一个目录只包含一个包，属于同一个包的源文件必须全部一起编译，一个包即一个单元，

**如果对一个包进行更改，那所有引用这个包的程序都需要重新进行编译**。

Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。

我们用例子来解释下编译顺序的原理：

假如`A.go` 引用了`B.go`,而`B.go`又引用了`C.go`，
- 编译顺序应该是先编译`C.go`，然后是`B.go`,最后编译的是`A.go`。
- 编译`A.go` 的时候读取的不是`C.go`编译文件`C.o`，而是读取`B.go`的编译文件`B.o`。

这种机制对于编译大型的项目时可以显著地提升编译速度。也就是说 **每一段代码只会被编译一次**，如果`C.go`没有被修改，重新编译`A.go`的时候只需要调用之前编译好的`B.o`文件即可，不需要重复去编译`B.go`源文件。

说完包的概念，接下来说说导入。

一个Go 程序是通过`import` 关键字将一组包连接在一起。

`import "fmt"`是告诉编译器这个程序需要使用到`fmt`包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 "" 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。

导入的语法有很多种，建议使用第三种

第一种
```go
import "fmt"
import "os"
```

第二种
```go
import "fmt"; import "os"
```
第三种
```go
import (
   "fmt"
   "os"
)
```

导入包的时候建议按照字母顺序进行导入，这样做更加清晰易读

如果包名不是以 . 或 / 开头，如 "fmt" 或者 "container/list"，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。

一般导入的包都是本地标准库或者线上库的包，如果我们要导入本地非标准库中的包要如何导入？这边分本地包在同一项目和不同一项目进行举例：
### 同一项目（比较常见）
```bash
.
├── pack1
│   └── pack1.go
├── go.mod
└── main.go
```
对于这种情况，从项目根目录到包名即可
```go
package main

import (
	"fmt"
	"project/pack1"
)
```
### 本地包不在同一项目
本地包不在同一项目也可以理解为要导入其他项目的 Go 文件，比如我在main.go中导入pack2/pack2.go文件。
```bash
.
├── pack2
│   └── pack2.go
└── project
    ├── pack1
    │   └── pack1.go
    ├── go.mod
    └── main.go

```
首先需要在pack2项目中通过go mod init pack2创建依赖工具
```go
module pack2Demo

go 1.19
```

接着修改project项目的依赖工具
```go
module project

go 1.19

require (
	pack2Demo v0.0.0
)

replace pack2Demo => ../pack2
```
不同项目导入主要用到require和replace关键字，require是声明引入的包名以及版本，replace是用来替换包的指向路径

导入包即等同于包含了这个包的所有的代码对象。

除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。

包通过下面这个被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件：






# 链接
* [目录](./directory.md)
* 上一页 [3.1 Go 的文件名、关键字和标识符](3-1.md)
* 下一页 