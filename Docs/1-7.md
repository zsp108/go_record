# Go runtime 和解释器

## Go runtime 
        虽然Go编译器产生的是可以本地可执行代码，但是这些代码还是运行在Go的runtime 上，Go的runtime 类似于Java 和 .NET所用到的虚拟机，它负责内存分配、垃圾回收、栈处理等等。
        runtime 在Go 1.5之前主要由C语言编写，Go 1.5版本后大部分使用Go编写实现，少量采用汇编语言，实现过程不再依赖于C语言，所以Go 1.5版本后构建时不需要使用C编译器了
        Go拥有简单却高效的标记-清除回收器，它的主要思想来源于IBM的可复用垃圾回收器，在Go 1.5版本中，除了使用Go实现runtime 外，还增加了并发的垃圾收集器，在可能情况下，垃圾回收和其他goroutine并发进行，可以极大降低响应时间。使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。
        Go的可执行文件都比对应的源文件大很多，这是由于Go runtime 嵌套进每个可执行文件中，，在部署数量巨大的集群时，大文件会是一个头疼的问题，但是相比于Java和Python来说要轻松很多，因为Go不需要依赖任何其他文件，它只是一个单独的静态文件。


## Go解释器
因为 Go 具有像动态语言那样快速编译的能力，自然而然地就有人会问 Go 语言能否在 REPL (read-eval-print loop) 编程环境下实现。Sebastien Binet 已经使用这种环境实现了一个 Go 解释器，你可以在这个页面找到：https://github.com/sbinet/igo。

# 链接
* [目录](./directory.md)
* 上一页 [1.6 在Mac OS X上部署Go](1-6.md)
* 下一页 [1.8 写个HelloWorld 吧](1-8.md)